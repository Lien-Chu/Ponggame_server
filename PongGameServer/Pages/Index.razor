@page "/"
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager Navigation
@implements IAsyncDisposable
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JSRuntime

<PageTitle>Index</PageTitle>

<div class="form-group">
	<label>
		Player name:
		<input @bind="user" />
	</label>
	<br /> <br />
	<button type="button" class="btn btn-success" @onclick="HandleJoinGame" disabled="@(!IsConnected)">Join the Game</button>

</div>
<br />

<ul id="messagesList">
	@foreach (var message in messages)
	{
		<li>@message</li>
	}
</ul>
<hr>
<div id="canvasContainer">
	<canvas id="canvas" width="640" height="280"></canvas>
</div>

@code {
	private HubConnection? hubConnection;
	private List<string> messages = new List<string>();
	private string? user;
	private int _playerId = -1;
	private static int playerNo = 0; // use something like this to keep track of the number of connected players
	private bool _isGameStarted = false;
	private int paddle_l;
	private int paddle_r;
	private int _ballX;
	private int _ballY;
	private int ballDX;
	private int ballDY;
	//private int playerCount = 0;


	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			/*
				* When we import and invoke javascript asynchronously like this
				* I believe we lose the ability to pass information back and forth
				* between the razor and the js
				*
				* Since the paddles are moved in the js, but the messages are handled in razor
				* we can't send paddle moved messages when the paddles are moved
				*
				* We either need to solve the problem of passing messages between
				* js and razor, or implement the paddle and ball movement in razor
				*
				* If we move the paddle and ball movement to razor, we have to also
				* handle drawing of the canvas in razor
				*
				* So the simple solution is just to move everything to razor and not import js
				*/
			await JSRuntime.InvokeVoidAsync("import", "/javascript/canvas.js");
			/*
			* this immediately starts the game animation
			* we should not start the game until we have at least 2 players
			*
			* good thing we have the playerNo variable to keep track of the
			* number of connected players
			*/
		}
	}


	private async Task HandleJoinGame()
	{
		if (hubConnection is not null)
		{
			await hubConnection.SendAsync("SendMessage", user);
		}
	}
	protected override async Task OnInitializedAsync()
	{
		hubConnection = new HubConnectionBuilder()
			.WithUrl(Navigation.ToAbsoluteUri("/gamehub"))
			.Build();

		/*
		* "ReceiveMessage" is a bad name for this command because it doesn't describe
		* what should happen when this is executed
		* 
		* This looks like the code that should be executed when a player joins the game
		* Maybe a better name would be "NewPlayerJoinedCommand"
		*/
		hubConnection.On<string>("ReceiveMessage", (user) =>
		{
			var encodedMsg = $"{user}" + " has joined the game!!";
			messages.Add(encodedMsg);
			InvokeAsync(StateHasChanged);

		});
		/*
			* This is the only place AssignPlayerId shows up in the code
			* It is never called, so this is dead code
			* You probably meant to do something here
			*
			* Either fix and use the code or remove it
			*/
		hubConnection.On<int>("AssignPlayerId", (playerId) =>
	{
		_playerId = playerId;
		_isGameStarted = true;
	});


		/*
			* This is also dead code; either fix the code or remove it
			*/
		hubConnection.On<int, int>("PaddleMoved", (playerId, newY) =>
		{
			if (playerId == 1)
			{
				paddle_l = newY;
			}
			else if (playerId == 2)
			{
				paddle_r = newY;
			}
		});
		/*
		* This is also dead code; either fix the code or remove it
		*/
		hubConnection.On<int, int>("BallMoved", (newX, newY) =>
	{
		_ballX += ballDX;
		_ballY += ballDY;
	});
		await hubConnection.StartAsync();
	}

	/*
	* This is dead code: not used by anything
	* If you meant to use the code, you should use it
	* If you did not mean to use the code, you should delete it
	*/
	private async Task OnKeyDown(KeyboardEventArgs e)
	{
		if (e.Code == "ArrowUp")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 1, paddle_l - 20);
			}
		}
		else if (e.Code == "ArrowDown")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 1, paddle_l + 20);
			}
		}
	}
	/*
		* dead code
		*/
	private async Task OnKeyUp(KeyboardEventArgs e)
	{
		if (e.Code == "w")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 1, paddle_l + 20);
			}

		}
		else if (e.Code == "s")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 1, paddle_l + 20);
			}
		}
		if (e.Code == "ArrowUp")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 2, paddle_l);
			}

		}
		else if (e.Code == "ArrowDown")
		{
			if (hubConnection is not null)
			{
				await hubConnection.SendAsync("MovePaddle", 2, paddle_l);
			}
		}
	}

	public bool IsConnected =>
		hubConnection?.State == HubConnectionState.Connected;

	public async ValueTask DisposeAsync()
	{
		if (hubConnection is not null)
		{
			await hubConnection.DisposeAsync();
		}
	}
}